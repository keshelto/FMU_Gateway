You are an expert Python engineer. Create a production-ready FMU Gateway service that runs uploaded FMUs (FMI 2.0/3.0, ME & CS) using FMPy in Docker on Fly.io. Priorities: security, determinism, small API surface, clear schemas, and runnable tests. Assume I have a Fly.io account and will set FLY_API_TOKEN as a GitHub secret.

Deliverables (single Git repo)
fmu-gateway/
  app/
    main.py
    simulate.py
    storage.py
    schemas.py
    kpi.py
    security.py
  tests/
    test_simulate_smoke.py
    test_md_parse.py
  Dockerfile
  requirements.txt
  fly.toml
  README.md
  .github/workflows/deploy.yml

Functional scope

Upload & register FMU

POST /fmus (multipart file upload).

Store on local disk (/app/data/<sha16>.fmu>). Parse modelDescription.xml → return {id, fmi_version, model_name, guid, sha256}.

Reject FMUs containing binaries for wrong platform (Windows DLL on Linux) unless source FMU is present.

List variables

GET /fmus/{id}/variables → list of {name, causality, variability, declaredType?} from modelDescription.xml.

Simulate

POST /simulate body:

{
  "fmu_id": "string",
  "stop_time": 1.0,
  "step": 0.001,
  "start_values": {"x": 1.0},
  "input_signals": [{"name":"u","t":[...],"u":[...]}],
  "kpis": ["y_rms"]
}


Use FMPy to run (ME or CS). Return:

{
  "id": "fmu_id",
  "status": "ok",
  "t": [...],
  "y": {"var":[...]},
  "kpis": {"y_rms": 0.0},
  "provenance": {"fmi_version": "...", "guid": "...", "sha256": "..."}
}


KPIs in kpi.py: implement y_rms and make it trivial to add others.

Non-functional & security

Timeouts: hard limit 20s per simulation; memory limit hint via environment (document).

Block network access during simulation. Do not execute arbitrary external processes.

Validate input arrays (monotonic time, lengths match).

Maximum output size: cap response JSON to ≤ 5 MB; otherwise return 413 with an error advising downsampling or selecting fewer variables.

Compute and store SHA-256 of uploaded FMU. Include it in provenance.

Sanitize filenames; never trust zip paths inside FMU.

Implementation details

Python 3.11, FastAPI, FMPy, pydantic v2, python-multipart.

simulate.py: thin wrapper around fmpy.simulate_fmu(...). Build the (names, matrix) tuple when input_signals are provided. Return deterministic lists (convert NumPy arrays).

storage.py: save_fmu(bytes)->(id,path), read_model_description(path)->meta.

security.py: checks for disallowed binaries, ZIP traversal, size limits.

schemas.py: Pydantic models for requests/responses exactly as above.

Dockerfile: python:3.11-slim; apt install gcc g++ cmake (FMPy builds C-code FMUs); expose port 8080; run uvicorn app.main:app.

requirements.txt:

fastapi==0.114.2
uvicorn[standard]==0.30.6
pydantic==2.9.2
fmpy[complete]==0.3.22
python-multipart==0.0.9


fly.toml (London region by default), auto-start/stop machines, internal_port 8080.

CI/CD: .github/workflows/deploy.yml uses superfly/flyctl-actions; deploy on pushes to main.

Tests (must pass locally in Docker)

test_md_parse.py: load a tiny sample FMU (include BouncingBall.fmu from FMPy’s test assets via download in test) → assert model name, FMI version present, ≥ 1 variable parsed.

test_simulate_smoke.py: run 0→5 s with step 0.01 on BouncingBall; assert status=="ok", time length > 0, and KPI computes when kpis=["y_rms"].

README.md (required sections)

What this is; architecture; security notes.

How to export an FMU from OpenModelica (GUI & translateModelFMU CLI).

Local dev: uvicorn app.main:app --reload.

cURL examples for /fmus, /variables, /simulate.

Fly.io deployment steps (set FLY_API_TOKEN secret, push to main).

Notes on bringing Simulink/GT-SUITE FMUs later (must be Linux-compatible or source FMU to rebuild).

Acceptance criteria

GET / returns service metadata and links to /docs.

Uploading a valid FMU returns id + metadata and persists file on disk.

Variable listing returns at least name and causality.

Simulating BouncingBall returns monotonic t, non-empty y, and a numeric y_rms KPI.

Zip traversal and Windows-only FMUs are rejected with clear 400 errors.

Image builds & runs locally; flyctl deploy --remote-only works.

Nice-to-have (if time allows)

S3_… env vars to switch storage backend; otherwise default to local disk.

/validate endpoint: small step-size convergence check (run at h and h/2 for a chosen output; report relative error).

## Phase 2 Tasks
Expand the FMU Gateway to host the full Modelica Standard Library (MSL) as pre-built FMUs for quick agent access and monetization:
- Export MSL models to FMUs using OpenModelica (batch script for FMI 3.0 CS/ME).
- Host in /app/library/msl directory; add GET /library endpoint for listing/searching models.
- Update /simulate to accept library fmu_id (e.g., "msl:BouncingBall") without upload.
- Create SDK (Python/JS) for easy agent integration (pip/npm install).
- Add caching (Redis) for fast repeats.
- Implement API keys (POST /keys) with auth for all endpoints.
- Track usage in DB (Fly Postgres) for billing.
- Integrate Google Cloud Billing/Stripe for per-simulation charging ($0.01/sim example).

## History of Work Done
- Created and deployed FMU Gateway on Fly.io with FastAPI, FMPy for FMI 2.0/3.0 ME/CS simulations.
- Implemented endpoints: /fmus (upload), /variables (list), /simulate (run with params/kpis).
- Fixed bugs: recursion in storage/simulate, temp file handling for Windows, meta dict conversion, keyword args for fmpy.
- Successful local test with BouncingBall.fmu (upload, list vars, simulate).
- Added "Capabilities for AI Agents" section to README.md.
- Pushed all fixes to GitHub, deployed via Actions.